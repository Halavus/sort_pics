#!/usr/bin/python
# -*- coding: utf-8 -*-
'''
This script has to be encoded in utf-8. (:set fileencoding=utf-8)
Because of the special FR-Chars é, û

It is called by a short bash script (sortpics.sh) because python is not good
at getting realpath of files without using os.walk().

The next implementation will be os.walk()

'''

import os
import sys
import numbers
from subprocess import Popen as Popen
from subprocess import PIPE as PIPE


try:
    source_list = sys.argv[1]
    '''
    source_list is a list stored in /tmp/path/to/list
    and generated by the bash command:
    find /path/to/lookup -type f >> /tmp/path/to/list
    '''

    with open(source_list, "rb") as f:
        '''
        Bash find appends "\\n" at end of each line
        '''
        files = [i[:-1] for i in f]
    
except IndexError:
    raise IndexError('No source list given.')

# NOTE Will be removed on profd. For debugging purpose only
print files


class File:
    # TODO
    '''
    __init__ should be shortened and a function convert() should be added
    '''
    def __init__(self, filepath):
        self.filename = os.path.basename(filepath)
        self.path = filepath
        
        '''oldie
        self.path = os.path.join(source_list, self.filename)
        '''
        months = {'01': u'Janvier',
                  '02': u'Février',
                  '03': u'Mars',
                  '04': u'Avril',
                  '05': u'Mai',
                  '06': u'Juin',
                  '07': u'Juillet',
                  '08': u'Août',
                  '09': u'Septembre',
                  '10': u'Octobre',
                  '11': u'Novembre',
                  '12': u'Décembre',
                  }

        def splitname(filename=self.filename):
            try:
                try:
                    isinstance(int(filename[:4]), numbers.Number)

                    year = filename[:4]
                    month = ' '.join([months[filename[4:6]], year[2:4]])
                    day = filename[6:8]
                    new_filename = filename

                except ValueError:

                    year = filename[4:8]
                    month = ' '.join([months[filename[8:10]], year[2:4]])
                    day = filename[10:12]
                    new_filename = filename[4:]

            except KeyError:
                raise ValueError("No valid month found.")

            if int(year) in range(1990, 2100):
                return [{'year': year, 'month': month, 'day': day}, new_filename]
            else:
                raise ValueError("No valid year found.")

        self.date = splitname()[0]
        self.new_filename = splitname()[1]
        
        def caller(lst): 
            '''bash command if more than 1 word have to be in a list'''
            proc = Popen(lst, stdout=PIPE)
            output = proc.stdout.read()
            return output

        if caller(["which", "md5deep"]):
            '''returns True if md5deep is installed'''
            if os.path.isfile(self.path):
                md5check = caller(["md5deep", self.path, "-k"])
                '''
                md5deep -k outputs: "md5sum */path/of/file"
                -k adds * before the path
                '''
                self.md5sum = md5check[:md5check.find("*") - 1]
            else:
                raise ValueError(
                    ' '.join([self.path, "Is maybe a directory?"])
                    )
        else:
            raise OSError("md5deep isn't installed")
        

sorted_root_dir = sys.argv[2]
out = sorted_root_dir

data_in = []

# TODO At this point files should be diffed with already sorted ones
# best using md5sum
for i in files:
    try:
        data_in.append(File(i))

    except ValueError:
        '''
        if the file don't follow the pattern, ignore it.
        '''
        pass


if not os.path.isdir(out):
    # checks if the dir exists otherwise create it

    if data_in:
        user_input = raw_input("The output root directory doesn't exists."
                               "Continue (Y/n): "
                               )
    else:
        sys.exit("No file to sort found.")
    if user_input == 'Y':
        os.mkdir(out)
    else:
        sys.exit("Aborded")

for i in data_in:
    # first we create the needed dirs
    path_year = os.path.join(out, i.date['year'])
    path_month = os.path.join(path_year, i.date['month'])
    path_newfile = os.path.join(path_month, i.new_filename)
    
    if not os.path.isdir(path_month) and not os.path.isdir(path_year):
        os.makedirs(path_month)
    else:
        if not os.path.isdir(path_month):
            os.mkdir(path_month)

    # then we hardlink the files
    # pass if file already exists
    # NOTE this should be prevented before !!
    # NOTE 2 : not so sure...
    try:
        os.link(i.path, path_newfile)
    except OSError:
        pass


class debug:
    def __init__(self):
        self.l = [i.filename for i in data_in]
