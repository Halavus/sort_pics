#!/usr/bin/python
# -*- coding: utf-8 -*-
'''
This script has to be encoded in utf-8. (:set fileencoding=utf-8)
Because of the special FR-Chars é, û

It is called by a short bash script (sortpics.sh) because python is not good
at getting realpath of files without using os.walk().

The next implementation will be os.walk()

'''

import os
import sys
import numbers
import cacher
from subprocess import Popen as Popen
from subprocess import PIPE as PIPE


cache = '/'.join([sys.argv[3], 'cached_images'])
cached_files = cacher.get(cache)

class File:
    # TODO
    '''
    __init__ should be shortened and a function convert() should be added
    '''
    def __init__(self, filepath):
        self.filename = os.path.basename(filepath)
        self.path = filepath

        if self.filename not in cached_files:

            print("Preparing "+self.filename)

            self.cached = False

            months = {'01': u'1 Janvier',
                      '02': u'2 Février',
                      '03': u'3 Mars',
                      '04': u'4 Avril',
                      '05': u'5 Mai',
                      '06': u'6 Juin',
                      '07': u'7 Juillet',
                      '08': u'8 Août',
                      '09': u'9 Septembre',
                      '10': u'10 Octobre',
                      '11': u'11 Novembre',
                      '12': u'12 Décembre',
                      }

            def splitname(filename=self.filename):
                try:
                    try:
                        isinstance(int(filename[:4]), numbers.Number)
                        '''for filenames like 2017012345_.jpg'''

                        year = filename[:4]
                        month = ' '.join([months[filename[4:6]], year[2:4]])
                        day = filename[6:8]
                        new_filename = filename

                    except ValueError:
                        '''for filenames like IMG_2017012345_.jpg'''

                        year = filename[4:8]
                        month = ' '.join([months[filename[8:10]], year[2:4]])
                        day = filename[10:12]
                        new_filename = filename[4:]

                except KeyError:
                    raise ValueError("No valid month found.")

                if int(year) in range(1990, 2100):
                    return [{'year': year, 'month': month, 'day': day}, new_filename]
                else:
                    raise ValueError("No valid year found.")

            self.date = splitname()[0]
            self.new_filename = splitname()[1]
            
            def caller(lst): 
                '''bash command if more than 1 word have to be in a list'''
                proc = Popen(lst, stdout=PIPE)
                output = proc.stdout.read()
                return output

            if caller(["which", "md5deep"]):
                '''Checks installation of md5deep, returns True if installed'''
                if os.path.isfile(self.path):
                    md5check = caller(["md5deep", self.path, "-k"])
                    '''
                    md5deep -k outputs: "md5sum */path/of/file"
                    -k adds a '*' before the path string
                    '''
                    self.md5sum = md5check[:md5check.find("*") - 1]
                else:
                    raise ValueError(
                        ' '.join([self.path, "Is maybe a directory?"])
                        )
            else:
                raise OSError("md5deep isn't installed")

        else:
            self.cached = True
            print self.filename+" already sorted"
        

sorted_root_dir = sys.argv[2]
out = sorted_root_dir

data_in = []


try:
    source_list = sys.argv[1]
    '''
    source_list is a list stored in /tmp/path/to/list
    and generated by the bash command:
    find /path/to/lookup -type f > /tmp/path/to/list
    '''
    
    files = cacher.get(source_list)

    # TODO use sys.walk instead of list from file

except IndexError:
    raise IndexError('No source list given.')


# TODO At this point files should be diffed with already sorted ones
# best using md5sum

def sort():
    for i in files:
        try:
            x = File(i)
            if x.cached == False:
                data_in.append(x)

        except ValueError:
            '''
            if the file don't follow the pattern, ignore it.
            '''
            print "Ignore "+i+"\n-> Doesn't follow the patern"
            pass


    if not os.path.isdir(out):
        # checks if the dir exists otherwise create it

        if data_in:
            user_input = raw_input("The output root directory doesn't exists."
                                   "Continue (Y/n): "
                                   )
        else:
            sys.exit("No file to sort found.")
        if user_input == 'Y':
            os.mkdir(out)
        else:
            sys.exit("Aborded")

    for i in data_in:
        # first we create the needed dirs
        print "Treatment of "+i.filename

        path_year = os.path.join(out, i.date['year'])
        path_month = os.path.join(path_year, i.date['month'])
        path_newfile = os.path.join(path_month, i.new_filename)
        
        if not os.path.isdir(path_month) and not os.path.isdir(path_year):
            os.makedirs(path_month)
            print "Generate folders "+path_month
        else:
            if not os.path.isdir(path_month):
                os.mkdir(path_month)
                print "Generate folder "+path_month
        try:
            os.link(i.path, path_newfile)
            # cache the file 
            cacher.add(cache, i.filename)
            print i.filename+" cached"

        except OSError:
            pass

        print("Sort "+i.path+" to "+path_newfile)

if __name__ == '__main__':
    sort()
